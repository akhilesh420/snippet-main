{
    "sourceFile": "functions/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1654023219568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1654023219568,
            "name": "Commit-0",
            "content": "const functions = require('firebase-functions');\r\nconst admin = require('firebase-admin');\r\nadmin.initializeApp();\r\nconst path = require('path');\r\nconst os = require('os');\r\nconst fs = require('fs');\r\nconst spawn = require('child-process-promise').spawn;\r\n\r\nconst runtimeOpts = {\r\n  timeoutSeconds: 540,\r\n  memory: '512MB'\r\n}\r\n\r\nconst runtimeOpts_content = {\r\n  timeoutSeconds: 540,\r\n  memory: '1GB'\r\n}\r\n\r\n\r\nconst bucket_name = 'snippet-web-9818a.appspot.com'; //snippet production\r\n// const bucket_name = 'snippet-test2.appspot.com'; //snippet testing\r\n\r\n\r\nexports.deleteUser = functions.https.onCall(async (data, context) => {\r\n\r\n  try {\r\n    const uid = data.uid;\r\n    functions.logger.info('Deleting user with uid:', uid);\r\n\r\n    await admin\r\n    .auth()\r\n    .deleteUser(uid)\r\n    .then(() => {\r\n      functions.logger.info('Successfully deleted user');\r\n      return 'Successfully deleted user';\r\n    })\r\n    .catch((error) => {\r\n      functions.logger.info('Error deleting user:', error);\r\n      return 'Error deleting user:'+ error;\r\n    });\r\n  } catch(e) {\r\n    functions.logger.info(e);\r\n  }\r\n});\r\n\r\nexports.createAdmin = functions.https.onCall(async (data, context) => {\r\n\r\n  try {\r\n    const uid = data.uid;\r\n    functions.logger.info('Creating admin with uid:', uid);\r\n\r\n    await admin\r\n    .auth()\r\n    .setCustomUserClaims(uid, {admin: true})\r\n    .then(() => {\r\n      functions.logger.info('Successfully created admin');\r\n      return { message: 'success'};\r\n    })\r\n    .catch((error) => {\r\n      functions.logger.info('Error creating admin:', error);\r\n      return  { message: 'Error creating admin:' + error};\r\n    });\r\n  } catch(e) {\r\n    functions.logger.info(e);\r\n  }\r\n});\r\n\r\nexports.deletePost = functions.https.onCall(async (data, context) => {\r\n\r\n  try {\r\n    const uid = data.uid;\r\n    const token = context.auth.token;\r\n\r\n    functions.logger.info('user token:', token);\r\n\r\n    // Verify the ID token first.\r\n    admin\r\n    .auth()\r\n    .verifyIdToken(idToken)\r\n    .then((claims) => {\r\n      if (claims.admin === true) {\r\n        // Allow access to requested admin resource.\r\n        functions.logger.info('Admin account');\r\n      }\r\n    });\r\n\r\n  } catch(e) {\r\n    functions.logger.info(e);\r\n  }\r\n});\r\n\r\nexports.contentCreate = functions.runWith(runtimeOpts_content).firestore\r\n.document('post content/{pid}')\r\n.onCreate(async (snap, context) => {\r\n\r\n  const fileBucket = bucket_name;\r\n\r\n  const newValue = snap.data();\r\n  const fileName = newValue.name;\r\n  const contentType = newValue.fileFormat;\r\n  const dimensions = {width: newValue.width.toString(), height: newValue.height.toString()};\r\n\r\n  functions.logger.info('File name:', fileName);\r\n  functions.logger.info('File type:', contentType);\r\n\r\n  const filePath = 'posts/' + fileName + '/original';\r\n  const bucket = admin.storage().bucket(fileBucket);\r\n  const tempFilePath = path.join(os.tmpdir(), fileName);\r\n\r\n  await bucket.file(filePath).download({destination: tempFilePath})\r\n              .catch((e) => functions.logger.info(e));\r\n\r\n  functions.logger.info('File downloaded locally to', tempFilePath);\r\n\r\n  let args = [];\r\n  let command = '';\r\n  if (contentType.startsWith('image/gif')) {\r\n    outputFilePath =  path.join(os.tmpdir(), 'optimized.gif');\r\n    command = 'convert';\r\n    args = ['-auto-orient',\r\n            '-strip',\r\n            '-coalesce',\r\n            '-sampling-factor',\r\n            '4:2:0',\r\n            '-quality',\r\n            '85',\r\n            '-interlace',\r\n            'Plane',\r\n            '-colorspace',\r\n            'RGB',\r\n            tempFilePath,\r\n            outputFilePath];\r\n  } else if (contentType.startsWith('image/')) {\r\n    outputFilePath =  path.join(os.tmpdir(), 'optimized.jpeg');\r\n    command = 'convert';\r\n    args = ['-auto-orient',\r\n            '-strip',\r\n            '-sampling-factor',\r\n            '4:2:0',\r\n            '-quality',\r\n            '85',\r\n            '-interlace',\r\n            'Plane',\r\n            '-gaussian-blur',\r\n            '0.05',\r\n            '-colorspace',\r\n            'RGB',\r\n            tempFilePath,\r\n            outputFilePath];\r\n  } else if (contentType.startsWith('video/')) {\r\n    outputFilePath =  path.join(os.tmpdir(), 'optimized.mp4');\r\n    command = 'ffmpeg';\r\n    args = ['-i',\r\n            tempFilePath,\r\n            '-c',\r\n            'copy',\r\n            '-map',\r\n            '0',\r\n            '-movflags',\r\n            '+faststart',\r\n            outputFilePath];\r\n  } else {\r\n    return functions.logger.info('Unsupported file type');\r\n  }\r\n\r\n  unlinkPaths = [tempFilePath, outputFilePath];\r\n\r\n  functions.logger.info('started processing', command, args);\r\n  await spawn(command, args).catch((e) => functions.logger.info(e));\r\n  functions.logger.info('finished processing');\r\n  functions.logger.info('uploading to storage', filePath);\r\n\r\n  const _metadata = { contentType: contentType, cacheControl: 'public, max-age=31536000', metadata: dimensions};\r\n  await bucket.upload(outputFilePath, { destination: filePath, metadata: _metadata})\r\n          .catch((e) => functions.logger.info(e));\r\n  functions.logger.info('uploaded to storage with metadata', _metadata);\r\n  finishUp(unlinkPaths);\r\n});\r\n\r\nexports.stickerCreate = functions.runWith(runtimeOpts).firestore\r\n.document('sticker content/{pid}')\r\n.onCreate(async (snap, context) => {\r\n\r\n  const fileBucket = bucket_name;\r\n\r\n  const newValue = snap.data();\r\n  const fileName = newValue.name;\r\n  const contentType = newValue.fileFormat;\r\n  const width = newValue.width;\r\n  const height = newValue.height;\r\n\r\n  const dimension = '150'; //Required size for small image\r\n\r\n  const dimensions = getDimensions(width, height, dimension);\r\n\r\n  functions.logger.info('File name:', fileName);\r\n  functions.logger.info('File type:', contentType);\r\n\r\n  let filePath = 'stickers/' + fileName + '/original';\r\n  const bucket = admin.storage().bucket(fileBucket);\r\n  const tempFilePath = path.join(os.tmpdir(), fileName);\r\n  let outputFilePath1 = '';\r\n  let outputFilePath2 = '';\r\n\r\n  await bucket.file(filePath).download({destination: tempFilePath})\r\n          .catch((e) => functions.logger.info(e));\r\n\r\n  functions.logger.info('File downloaded locally to', tempFilePath);\r\n\r\n  filePath = 'stickers/' + fileName + '/small';\r\n\r\n  if (contentType.startsWith('image/gif')) {\r\n    outputFilePath1 =  path.join(os.tmpdir(), 'resized.gif');\r\n    outputFilePath2 =  path.join(os.tmpdir(), 'optimized.gif');\r\n  } else if (contentType.startsWith('image/')) {\r\n    outputFilePath1 =  path.join(os.tmpdir(), 'resized.jpeg');\r\n    outputFilePath2 =  path.join(os.tmpdir(), 'optimized.jpeg');\r\n  } else {\r\n    return functions.logger.info('Unsupported file type');\r\n  }\r\n\r\n  const args1 = ['-i',\r\n                  tempFilePath,\r\n                  '-vf',\r\n                  'scale=w=' + dimension + ':h=' + dimension + ':force_original_aspect_ratio=increase',\r\n                  outputFilePath1];\r\n\r\n  const args2 = ['-auto-orient',\r\n                 '-strip',\r\n                 '-interlace',\r\n                 'Plane',\r\n                 '-colorspace',\r\n                 'RGB',\r\n                 outputFilePath1,\r\n                 outputFilePath2];\r\n\r\n  const unlinkPaths = [tempFilePath, outputFilePath1, outputFilePath2];\r\n\r\n  functions.logger.info('started processing ffmpeg', args1);\r\n  await spawn('ffmpeg', args1).catch((e) => functions.logger.info(e));\r\n  functions.logger.info('finished processing ffmpeg');\r\n  functions.logger.info('started processing convert', args2);\r\n  await spawn('convert', args2).catch((e) => functions.logger.info(e));\r\n  functions.logger.info('finished processing convert');\r\n  functions.logger.info('uploading to storage', filePath);\r\n\r\n  const _metadata = { contentType: contentType, cacheControl: 'public, max-age=31536000', metadata: dimensions};\r\n  await bucket.upload(outputFilePath2, { destination: filePath, metadata: _metadata})\r\n          .catch((e) => functions.logger.info(e));\r\n  functions.logger.info('uploaded to storage with metadata', _metadata);\r\n  finishUp(unlinkPaths);\r\n});\r\n\r\nexports.dpCreate = functions.runWith(runtimeOpts).firestore\r\n.document('display picture/{uid}')\r\n.onWrite(async (change, context) => {\r\n\r\n  const fileBucket = bucket_name;\r\n\r\n  const newValue = change.after.data();\r\n  const fileName = newValue.name;\r\n  const contentType = newValue.fileFormat;\r\n  const width = newValue.width;\r\n  const height = newValue.height;\r\n\r\n  const dimension = '200'; //Required size for small image\r\n\r\n  const dimensions = getDimensions(width, height, dimension);\r\n\r\n  functions.logger.info('File name:', fileName);\r\n  functions.logger.info('File type:', contentType);\r\n\r\n  let outputFilePath1 = '';\r\n  let outputFilePath2 = '';\r\n\r\n  if (contentType.startsWith('image/gif')) {\r\n    outputFilePath1 =  path.join(os.tmpdir(), 'resized.gif');\r\n    outputFilePath2 =  path.join(os.tmpdir(), 'optimized.gif');\r\n  } else if (contentType.startsWith('image/')) {\r\n    outputFilePath1 =  path.join(os.tmpdir(), 'resized.jpeg');\r\n    outputFilePath2 =  path.join(os.tmpdir(), 'optimized.jpeg');\r\n  } else {\r\n    return functions.logger.info('Unsupported file type');\r\n  }\r\n\r\n  let filePath = 'display pictures/' + fileName + '/original';\r\n  const bucket = admin.storage().bucket(fileBucket);\r\n  const tempFilePath = path.join(os.tmpdir(), fileName);\r\n\r\n  await bucket.file(filePath).download({destination: tempFilePath})\r\n          .catch((e) => functions.logger.info(e));\r\n\r\n  functions.logger.info('File downloaded locally to', tempFilePath);\r\n\r\n  filePath = 'display pictures/' + fileName + '/small';\r\n\r\n  const args1 = ['-i',\r\n                  tempFilePath,\r\n                  '-vf',\r\n                  'scale=w=' + dimension + ':h=' + dimension + ':force_original_aspect_ratio=increase',\r\n                  outputFilePath1];\r\n\r\n  const args2 = ['-auto-orient',\r\n                 '-strip',\r\n                 '-interlace',\r\n                 'Plane',\r\n                 '-colorspace',\r\n                 'RGB',\r\n                 outputFilePath1,\r\n                 outputFilePath2];\r\n\r\n  const unlinkPaths = [tempFilePath, outputFilePath1, outputFilePath2];\r\n\r\n  functions.logger.info('started processing ffmpeg', args1);\r\n  await spawn('ffmpeg', args1).catch((e) => functions.logger.info(e));\r\n  functions.logger.info('finished processing ffmpeg');\r\n  functions.logger.info('started processing convert', args2);\r\n  await spawn('convert', args2).catch((e) => functions.logger.info(e));\r\n  functions.logger.info('finished processing convert');\r\n  functions.logger.info('uploading to storage', filePath);\r\n\r\n  const _metadata = { contentType: contentType, cacheControl: 'public, max-age=31536000', metadata: dimensions};\r\n  await bucket.upload(outputFilePath2, { destination: filePath, metadata: _metadata})\r\n          .catch((e) => functions.logger.info(e));\r\n  functions.logger.info('uploaded to storage with metadata', _metadata);\r\n  finishUp(unlinkPaths);\r\n});\r\n\r\nfunction getDimensions(width, height, dimension) {\r\n  if (width == 0 || height == 0) return;\r\n  let _dimensions;\r\n  if (width > height) _dimensions  = {width: dimension * (width/height), height: dimension};\r\n  _dimensions = {width: dimension, height: dimension * (height/width)};\r\n  return {width: _dimensions.width.toString(), height: _dimensions.height.toString()};\r\n}\r\n\r\nfunction finishUp(unlinkPaths) {\r\n  unlinkPaths.forEach((filePath) => fs.unlinkSync(filePath));\r\n  functions.logger.info('Finished execution');\r\n}\r\n\r\n\r\n"
        }
    ]
}